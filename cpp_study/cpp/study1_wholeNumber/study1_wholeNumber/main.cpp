#include <iostream>
using namespace std;

// 드래그 후 전체 주석 = ctrl + k + c (comment), 반대는 u (uncomment)
// 변수 선언: [타입] [이름] = [초기값];

// 0이 아닌 초기화 값이 있으면 .data 영역에 저장

int hp = 100;

//초기 값이 0이거나, 초기 값이 없는 변수 .bss 영역에 저장

char a; // 1바이트 (-128~127)
short b; // 2바이트 (-32768~32767)
int c; // 4바이트 (-21.4억~21.4억)
__int64 d; // 8바이트 (long long) (어마어마하게 큼)

unsigned char ua; // 1바이트 (0~255)
unsigned short ub; // 2바이트 (0~65536)
unsigned int uc; // 4바이트 (0~42.9억)
unsigned __int64 ud; // 8바이트 (long long) (어마어마하게 큼)

/*
참고) 이론적으로 양수만 존재할 수 있는 데이터라면? 무조건 언싸인드 써야할까?
의견이 갈림
- 레벨이 음수인건 말이 안된다 vs 말이 안되면 차라리 일부러 음수로 크래쉬 내서 버그를 찾자
- 그리고 언싸인드와 싸인드 사이의 변환 과정에서 버그가 일어날 수 있음

그래서 순수하게 코딩 스타일 차이임
*/

/*
귀찮은데 그냥 대충 4바이트로 가면 안될까?

콘솔 모바일게임은 늘 메모리가 부족함, 그래서 1바이트라도 아껴야함
온라인 게임은 심지어 체력 정보 4바이트를 매초마다 몇만명에서 보내야함
*/

int main()
{
	b = 32767;
	b = b + 1;
	cout << b << endl; // -32768 , 정수 오버플로우

	ub = 0;
	ub = ub - 1;
	cout << ub << endl; // 65536 , 정수 언더플로우
	cout << "체력이 " << hp << " 남았습니다." << endl;
}