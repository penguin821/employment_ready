<타입 변환의 유형>
1. 값 타입 변환
의미를 유지하기 위해서 원본 객체와 다른 비트열 재구성
int a = 1234567 // 2의 보수로 이루어짐
float b = (float)a // 부동소수점(지수와 유효숫자)로 이루어짐

2. 참조 타입 변환
데이터와 비트열만 유지하고 의미는 달라짐
int a = 1234567 // 2의 보수로 이루어짐
float b = (float&)a // 부동소수점(지수와 유효숫자)로 이루어짐
이렇게 하면 비트열은 그대로지만 값이 완전히 다른 값이 나옴
(사실상 우리가 의도한 타입 변환이 아님)
-------------------------------------------------------------------------------------------
<안전도에 따라>
1. 안전한 변환
의미가 항상 100% 완전히 일치함
같은 타입이면서 데이터 담는 사이즈만 더 커짐
작은 바구니 -> 큰 바구니 (업캐스팅)
int a = 1234567
_int64 b = a

2. 불안전한 변환
의미가 항상 100퍼 같다고 보장 못함
타입이 다르거나 같은 타입이지만 큰바구니->작은바구니로 담을때 (다운캐스팅)
int a =1234567
float b = a
short c = b
결과 보면 디트 단위로 짤려서 다른 숫자가 나와버림
-------------------------------------------------------------------------------------------
<프로그래머 의도에 따라>
1. 암시적 변환
이미 알려진 타입 변환 규칙에 따라 컴파일러가 자동으로 타입을 변환해줌
int a =1234567
float b = a;

2. 명시적 변환
int a =1234567
int* b = (int*) a; // 직접 뭐로 바꿀지 내가 지정
-------------------------------------------------------------------------------------------
<아무 연관이 없는 클래스 사이의 변환>

cpp 파일 참조

------------------------★★★★★★매우 중요★★★★★★--------------------------
그래서 임시적으로 명시적으로 부모 자식 간의 클래스 변환을 할때
지식 포인터를 부모 포인터로 형 변환 할 시
부모와 자식 생성자가 다 호출이 된다
그러나 부모 포인터의 메모리를 반납할때
부모 클래스의 소멸자만 호출되고 자식 클래스의 소멸자는 호출이 안됨

따라서 부모 생성자의 소멸자를 선언할때 꼭 virtual로 선언해서 가상 함수로 만들어
강제로 오버라이딩 된 본인 소멸자가 각자 호출 되도록 해줘야 깔끔하게 반납이 된다

ㅣ상속 관계에서 재정의를 해봤자 재정의 된 클래스만 소멸자가 호출되기 때문에 ㅣ
ㅣvirtual을 붙여 가상 함수로 소멸자를 호출하면 가상 함수 테이블이 만들어지게 되어ㅣ
ㅣ실제 객체, 즉 원본이 어떤 클래스로 만들어졌냐에 따라 해당 클래스의 소멸자를 찾아서 호출하게 된다ㅣ
