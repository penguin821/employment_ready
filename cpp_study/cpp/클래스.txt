클래스 a(b); // 복사 생성자를 탐
클래스 a = b; // 복사 생성자를 탐

그러나
클래스 a;
a=b; // 이렇게 선언 시 기본 생성자를 탐

명시적 : 우리가 코드로 직접적인 형변환을 지시함
암시적 : 별말 안해도 컴파일러가 알아서 처리하게 함

explicit 생성자 = 컴파일러 마음대로 타입 변환 생성자를 타는것을 막음
우리가 직접적으로 이 생성자를 타게 하는게 아닌이상 이 생성자를 타지 마라는 명시적 용도
그래도 우리가 뭐하는지 다 알고있고 해당 생성자를 타라고 지시할땐
클래스 a = (클래스)b
함수((클래스)a) 이런식으로 사용할 것 

----------------------------------------------

객체지향 (OPP 오브젝트 오리엔티드 프로그래밍)

<상속성>
클래스 자식 : public 부모

부모생성자->자식생성자->자식소멸자->부모소멸자 인것 같지만 사실
어셈블리 단계로 쪼개어보면 자식생성자를 타긴 타는데 
자식 생성자 ()
-> 요 공간에서 부모 생성자가 호출된다 = 선처리 영역이라고 책에서 부름
{
	생성자 내용
}

소멸자도 마찬가지임
자식 소멸자()
{
	소멸자 내용
}
-> 요 공간에서 부모 소멸자가 호출 = 후처리 영역

자식 생성자 중에서 부모 기본 생성자 말고 부모의 특정 생성자를 타게 만들고 싶으면
자식생성자() : 부모생성자(값)으로 만들면 됨
----------------------------------------------
<은닉성> = 캡슐화

public - 어디에서든 접근 가능
private - 해당 클래스에서만 접근
protected - 내 자식만 접근
----------------------------------------------
<다형성> = 겉은 같은데 기능이 다르게 동작함

오버로딩 = 함수 중복 정의, 함수 이름의 재사용, 매개변수의 갯수나 타입이 다름
오버라이딩 = 재정의 = 부모 클래스의 함수를 자식 클래스에서 재정의 함 

정적 바인딩(스태틱 바인딩) = 컴파일 시점에서 결정(일반적인 함수는 다 정적 바인딩)
동적 바인딩(다이나믹 바인딩)<면접단골질문> = 실행 시점에서 결정 -> 가상 함수 이용

맴버 함수에 virtual 붙이는 순간 걔는 영원한 가상 함수임, 오버라이딩 불가
virtual 붙이면 강제로 오버라이딩 된 본인(부모는 부모꺼, 자식은 자식꺼) 함수가 실행됨

근데 어떻게 가상 함수는 지가 알아서 찾아갈까?
어셈블리 단계에서 가상 함수 테이블(vftable)라는게 생성돼서
테이블에 가상 함수들이 등록되고, 호출된 클래스 타입으로 테이블이 덮어쓰기 됨

순수 가상 함수 = 구현은 없고 인터페이스만 전달하는 용도
virtual 자료형 함수명() = 0; / virtual 자료형 함수명() abstract;

추상 클래스 = 순수 가상 함수가 1개 이상 있으면 해당 클래스는 추상 클래스
추상 클래스는 직접적으로 객체를 만들 수 없게 됨
즉 무조건 상속을 받아서 해당 순수 가상 함수를 구현을 해야만 사용가능

