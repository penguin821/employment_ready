실행할 코드 내용이 저장되는 영역 = 코드영역
전역, 정적 함수 변수 = 데이터 영역
지역, 매개 함수 변수 = 스택 영역

동적 할당 = 힙 영역

우리가 필요할때만 사용하고 반납도 할 수 있는
생성 소멸 시점을 관리할 수 있는 메모리 = HEAP

malloc free new delete new[] delete[]

컴퓨터 프로그램의 실행은 유저 영역과 커널 영역으로 나뉘어져있음
커널 영역은 윈도우의 시스템 파일 같은 핵심 파일들이 돌아가고
유저 영역이 우리가 사용하는 흔한 프로그램들 메모장 롤 같은거

<힙 영역은 어떻게 사용하냐>
메모리 할당을 하면
유저 영역 - 메모리 달라고 요청하면 운영 체제에서 제공하는 API 호출
커널 영역 - 메모리 할당해줌
유저 영역 - 사용
과정을 거친다.

C++에서는 기본적으로 CRT(C런타임 라이브러리)의 힙 관리자를 통해 힙 영역 사용
우리가 정말 원한다면 직접 API를 통해 힙을 생성하고 관리할 수 있음(서버 메모리 풀링 기법)

<*void 란?? 보이드 포인터>
포인터이긴 포인터인데 주소를 타고 가면 말그대로 void이다
즉 주소대로 가면 뭐가 있을지 모르겠으니까 적당히 변환해서 사용해라는 의미
즉 자료형이 뭐가될지 모르니 알아서 판단해서 맞추라는 용도

<Heap Overflow>
할당받은 유효한 힙 범위 초과해서 사용할때

<free를 하지 않으면>
메모리 누수가 일어남, 당장은 에러뜨면서 모든 메모리가 다 소비됐을때 터짐

<Double Free>
소멸을 여러번 시키면 걍 크래쉬 나면서 끝남

<Use-After-Free>
동적 할당이 말그대로 포인터다 보니까
free를 해서 메모리를 반납했는데 포인터는 남아있다보니
free 이후에 해당 포인터의 객체에 접근할 수 있음
문제는 포인터에 접근한거라 크래쉬도 안남
해당 포인터의 주소값이 쓰레기 값이 됐지만
그 쓰레기 값의 객체에 접근했을때 그 메모리 주소가
이미 존재하는 객체의 주소값을 건드는 순간 진짜 개망한거임
당장 크래쉬도 안나고 어디서 이런일이 일어난건지 찾기도 힘듦

Monster* pointer = (Monster*)malloc(12);
free(pointer);

Monster m1 = new Monster;
delete m1;

Monster m2 = new Monster[5];
delete[] m2;

<malloc/free vs new/delete 차이점>
mf는 C언어때 있었고 nd는 C++에 추가된 문법이다
mf는 함수이고 nd는 연산자이다
사용 편의성은 nd 승이지만 타입 상관 없이 특정 크기의 메모리 영역을 할당받는건 mf 승
@@@가장 중요한 차이점은 new delete할때 생성 타입이 클래스 일 경우 생성자/소멸자를 호출해준다
즉 new delete는 객체지향과 찰떡궁합임