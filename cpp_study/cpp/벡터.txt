STL Standard Template Library
프로그래밍할 때 필요한 자료구조/알고리즘들을 템플릿으로 제공하는 라이브러리

컨테이너 : 데이터를 저장하는 객체 (즉, 자료구조를 의미함 (Data Structure) )

vector는 동적배열
1. 중간 삽입 삭제 = 중간에 뿅하고 새로 못만든다, 뒤로 한칸씩 밀어서 삽입, 삭제하면 뒤에서 빈칸으로 한칸씩 땡겨와야함 = 비효율적
2. 처음 삽입 삭제 =중간 삽입이랑 같음 비효율적
3. 끝 삽입 삭제 =  뒤에서 땡겨오는 구조라 끝 삽입 삭제는 걍 지우고 넣고하면 끝 = 효율적 (그래서 push back은 있는데 앞에 넣는건 없음, 괜히 만들었다가 사람들이 막쓸까봐)
4. 컨테이너 임의접근 = v[2]=3 이라는 문구가 통한다는거 자체가 임의접근하기 용의하다는 뜻

★★★★ 일반 배열과 다르게 동적 배열은 어떻게 유동적인 배열이 가능한가? ★★★★

1. 미리 여유분을 두고 메모리를 할당함
2. 여유분이 꽉 차면 새로 메모리를 증설함
즉, 동작 방법은 여유분을 둔 메모리를 할당하여 거기에 배열처럼 연속적으로 데이터를 저장한다

그렇다면
1. 여유분이 얼만큼이 적당한가?
2. 메모리 증설을 얼만큼씩 하는가?
3. 증설하면 기존의 메모리는 어떻게 처리하는가?

size()					실제 사용 중인 데이터 갯수 (하나씩 증가함)
capacity()				여유분을 포함한 용량 갯수 (1.5배씩 증가함)
clear()					size를 0으로 만들어줌, capacity는 그대로
reserve(용량)				capacity 미리 설정 가능 (capacity만 셋팅됨) (이미 설정된 capacity 이상의 값을 설정했을때만 작동)
resize(용량)				size를 미리 설정 가능 (size랑 capacity 둘다 셋팅됨)
vector<자료형> 변수명(용량)  	으로 초기화 가능(전부 0이 들어감), 용량은 resize랑 똑같이 작동, (용량, 초기값) 으로 전체 초기화도 가능
vector<자료형> 변수명(용량, 초기화값)
insert(변수명.begin()+이동할칸, 값) / iterator 사용시 삽입한곳 가리킴
erase(변수명.begin()+이동할칸 / iterator 사용시 지운곳 가리킴
erase(변수명.begin()+이동할칸(이상), 변수명.begin()+이동할칸(미만)) 이상 미만 범위로 삭제됨 / 지운곳 가리킴

기존 메모리를 초과해서 연장하려니 혹시나 뒤에 다른 메모리가 잡혀있으면 연장하기 힘들다
그래서 그냥 새로운 메모리 공간을 잡아서 거기로 기존 데이터를 옮긴다
새로 옮길때 1.5배 만큼 확장한 새 메모리를 잡아 옮기는 것이 C++에서 동적배열이 판단한
가장 중립적이고 효율적인 수치

★★★★ 벡터를 사용할때 왜 미리 reserve로 메모리 용량을 잡아주고 시작하냐? ★★★★

reserve로 미리 안잡고 시작한 상태에서 size가 계속해서 늘어나면 capacity 한도에 도달할때마다
새롭게 capacity를 증설하여 거기다가 기존 데이터를 복사해서 집어넣는 과정이 일어나는데
문제는 용량이 커질수록 증설,복사 비용이 증가하기 때문에 얼추 데이터 사이즈를 안다면
reserve로 미리 잡아주고 시작하는게 불필요한 동작을 없애주고 더 효율적이기 때문이다. 

clear 로 size 0으로 만들어주고 capacity도 0으로 만들고 싶다면 reserve는 안통함, 이미 잡힌 capacity 보다 작은 값은
작동을 안한다. vector<자료형>().swap(0으로 만드려는 백터 객체) 를 이용, 임시 벡터를 하나 만들어서 바꿔치기 해주는게 정석
그런데 실무에선 어지간하면 한번 늘어난 capacity를 줄이는 작업은 잘 안함, 왜냐면 그정도로 capacity가 늘어났다는건
추후에도 또 그정도로 늘어날 일이 다분한 벡터라는 뜻이기 때문
