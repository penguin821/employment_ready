<컨텍스트 스위칭>

하나의 프로세스를 실행하고 있는 상태에서 다음 우선 순위의 프로세스가 실행되어야 할 때 기존의 프로세스의 레지스터들을 메모리에 저장하고 메모리에 존재하는 다음 프로세스의 정보를 레지스터로 옮기는것
==========================================================
<enum struct class 차이점>

클래스는 참조 타입이지만, 열거형과 구조체는 값 타입이다.
클래스는 상속이 가능하지만 열거형과 구조체는 상속이 불가능합니다.
이 세가지 모두 확장(extension)이 가능합니다.
==========================================================
<멀티쓰레드와 뮤텍스>

멀티스레드 - 2개 이상의 스레드를 가지는 프로세스, 스택 영역을 제외한 힙 데이터 코드 영역의 자원을 스레드끼리 공유하기 때문에 자원의 생성과 관리의 중복을 최소화 하여 CPU 사용율을 향상 

임계영역 - 프로그램에서 임계 자원을 이용하는 부분으로 공유 자원의 독점을 보장하는 코드 영역

뮤텍스 - 프로세스나 쓰레드 간의 공유 메모리 자원에 대한 접근 제어를 하기위해 사용되는 동기화 기법. 세마포어와는 다르게 오직 하나의 스레드만이 공유 자원에 접근할 수 있도록 보장하며, lock상태와 unlock 두가지 상태를 가져 공유 자원을 관리

세마포어 - 원하는 만큼의 스레드가 임계영역에 들어가도록 허용시킨 기법
==========================================================
<동적할당과 스마트 포인터>

동적할당- 프로그램 실행 중에 메모리를 필요에 따라 할당하고, 필요 없어지면 해제하는 작업

장점 : 유연한 메모리 관리, 효율적인 자원 사용, 데이터 생명주기 제어
단점 : 해제 안하면 메모리 누수, 해제시 해제된 메모리를 참조하는 뎅글링 포인터

스마트포인터 - 포인터 처럼 사용하는 클래스 템플릿으로 메모리를 자동으로 해제해 메모리 누수를 방지

스마트 포인터는 new 키워드를 사용해 일반 포인터가 실제 메모리를 가리키도록 초기화한
후 기본 포인터를 스마트 포인터에 대입하여 사용한다. 
이렇게 정의된 스마트 포인터가 수명이 다하면 소멸자를 통해 delete 키워드를 
자동으로 사용해 메모리를 해제한다. 따라서 따로 메모리를 해제할 필요가 없게 된다.

shared_ptr 어떤 하나의 객체를 참조하는 스마트 포인터의 개수를 참조하는 스마트 포인터이다.
	    참조 카운트(reference count), 해당 메모리를 참조하는 포인터가 몇개인지 나타내는 값
unique_ptr 하나의 스마트 포인터만이 객체를 가리킬수 있도록 한다. 
		reference count가 1을 넘길수 없다.
weak_ptr 하나 이상의 객체를 참조할수 있지만 reference count를 늘리지않음
		서로가 서로를 가리켜 reference count가 0이 안되는 순환 참조 제거용

RAII 기법의 대표적인 예시
==========================================================
<스택 힙 메모리 차이점>

- 힙 영역
 프로그래머가 직접 관리할 수 있는 메모리 영역으로 이 공간에서 메모리를 할당하는 것을 동적할당이라 부른다.
힙 영역은 스택 영역과 달리 낮은 주소에서 높은 주소로 메모리가 할당 된다.

- 스택 영역
 함수의 호출과 함께 할당되며 지역 변수와 매개 변수가 저장되는 영역이다. 스택 영역에 저장되는 함수의 호출 정보를 스택프레임이라 한다.
스택 영역은 함수 호출이 완료되면 소멸하고 높은 주소에서 낮은 주소로 메모리가 할당된다.
==========================================================
<상속, 오버로딩, 오버라이딩, 가상함수, 순수 가상 함수, 가상 함수 테이블>

오버로딩 - 인자의 자료형이나 수가 다른 함수를 같은 이름으로 여러번 중복 정의

오버라이딩 - 부모 클래스와 자식 클래스의 상속 관계에서, 부모 클래스에 이미 정의된 함수를 			같은 이름으로 자식 클래스에서 재정의 하는것

상속 - 상위 클래스의 속성, 메소드를 하위 클래스가 그대로 물려받는 것

가상함수 - 만약 오버라이딩 된 함수를 부모 포인터로 선언하고 자식의 주소값에 대입하면 자식이 아닌 부모의 함수가 나옴. 컴파일러가 객체의 자료형이 아닌 포인터 변수의 자료형을 기준으로 판단하기 때문. 이러한 문제를 방지하기 위해 가상함수 virtual 키워드를 앞에 붙여 사용
가상함수는 코드 실행 시 객체의 자료형을 따라감

순수 가상 함수 - 선언만 있고 정의는 없어서 자식 클래스에서 반드시 재정의해야하는 가상함수

가상함수테이블 - 컴파일 시 가상함수가 정의된 클래스가 있다면 해당 클래스에 가상함수테이블이 만들어져 바이너리 rdata 영역에 기록되어 객체에서 함수 호출할 때 가상함수테이블을 참조함
==========================================================
<프로세스와 쓰레드>

프로세스는 실행 중인 프로그램을 의미하며, 독립된 메모리 공간을 가집니다. 반면, 스레드는 프로세스 내에서 실행되는 실행 단위로, 프로세스의 자원을 공유하면서 동작합니다.

왜냐하면 프로세스 각각 독립된 메모리 공간을 가지기 때문에, 프로세스 간의 자원 공유는 IPC(Inter-Process Communication)를 통해 이루어집니다. 반면, 스레드는 같은 프로세스 내에서 메모리를 공유하기 때문에 데이터 공유가 더욱 용이합니다.

stack 영역만 스레드가 별도로 가져야 독립적인 함수 호출과 실행 흐름을 가질 수 있음
==========================================================
<RAII>

자원 획득(Resource Acquisition)은 초기화(Initialization)이다
프로그램을 짜다보면 동적 메모리 할당, 파일 열기, 락 등 자원 획득을 하는 일이 많은데
이러한 자원 획득을 담당하는 클래스를 만들어 그 클래스의 생성자에서만 자원 획득을 하라

자원을 사용하고자 하는 상황에서, 생성자에서 자원 획득을
소멸자에서 자원 해제를 하는 자원 관리용 클래스를 만드는 프로그래밍 디자인 패턴

이렇게 되면 자원의 생애 주기는 객체의 생애와 결합된다
객체의 생애는 런타임이 알아서 잘 관리해준다고 하였다
즉 그렇기에 앞으로는 객체와 바인딩된 자원은 런타임이 자동으로 관리할 수 있다.
==========================================================
<포물선 운동>
x = v0*cosθ*t
y  = v0*sinθ*t-½g*(t^2)

v = 운동을 시작한 힘(초기속도)
g = 중력가속도 (9.8m/s2)
t = 물체가 포물선 운동을 시작한 이후 현재까지의 시간의 누적합

<가속도 법칙>
F = m(질량)a(가속도) 
a = (v - v0) / (t - t0) : v속도 t시간 : 등가속도면 그냥 t

<내적 외적>
내 = abcosθ, a1b1+a2b2+a3b3   θ 값은 빗변이 2, 나머지가 1,루트3인 삼각형 생각
외 = absinθ, -(a1b3-a3b1)y
 x  -y  z
a1 a2 a3
b1 b2 b3
==========================================================
<빅오표기법>
복잡도에 가장 영향을 많이 끼치는 항의 상수인자를 빼고 나머지 항을 없애서 복잡도 나타내는 표기법